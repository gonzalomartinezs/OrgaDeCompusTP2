# benchmark-b0.S - Trabajo Práctico 2
# Organización de Computadoras 66.20/86.37
# Facultad de Ingeniería, Universidad de Buenos Aires.
#
# $Date: 2020/05/26 02:04:47 $

#include <regdef.h>
#include <sys/asm.h>
#include <sys/syscall.h>

	.text
	.align	2

	.globl	main
	.ent	main
main:
	.set	noreorder
	.cpload	t9		-> .cpload se expande en 3 instrucciones. Cuando se busca la primera ocurre un MISS, entonces se guarda en la caché de instrucciones el bloque de 16 bytes (4 instr.) que la contiene. Como las instrucciones se guardan consecutivas en memoria, este bloque contiene las últimas 2 instrucciones de .cpload, por ende cuando el CPU procede a buscarlas en caché resultan ambas en HIT. (el index en n%4)
	.set	nomacro
	addiu	sp, sp, -24	-> Puesto que esta instrucción también se encontraba en el bloque cargado previamente en la caché, resulta en un HIT. 
	sw	fp, 20(sp)	-> Se busca esta instrucción en su respectiva caché, lo cual resulta en MISS. Por lo cual, se carga en la caché de instrucciones ésta y las siguientes 3 instrucciones. (el index es (n+1)%4). Por otro lado, en la caché de datos no se encuentra la dirección correspondiente a 20(sp), produciéndose un MISS. De esta manera, se carga en la caché el bloque de 16 bytes que contiene dicha dirección (el index es n%4) PONELE.  
	move	fp, sp		-> Se encuentra en el mismo bloque de caché que la instrucción anterior, razón por la cual es un HIT.
	.cprestore	0	-> Esta directiva se interpreta como la siguiente instrucción 'sw     gp,0(sp)', la cual también se encuentra en el segundo bloque cargado en caché. Es un HIT. Por otra parte, la dirección correspondiente a 0(sp) no se encuentra en la caché de datos, resultando en un MISS. Así, se carga en la caché el bloque de 16 bytes que contiene dicha dirección (el index es (n+1)%4).

	la	t0, aligned	-> Por las mismas razones que el caso anterior, HIT en la caché de instrucciones. Sin embargo, se produce un MISS de lectura en la caché de datos, pues no se encuentra el dato asociado a la dirección de 'aligned'. Como consecuencia se carga el bloque de memoria que contiene dicha dirección en la correspondiente caché (el index es (n+2)%4).
	.align	20
	li	t1, 100		-> No se encuentra esta instrucción en el caché de instrucciones, por ende es un MISS. Se carga el bloque de 16 bytes que la contiene en la caché. (el index es (n+2)%4).
loop:	lw	t2, 1024(t0)	-> Esta instrucción se encuentra en el ùltimo bloque cargado en caché. Al tratarse de 100 iteraciones, se producen 100 HITs en la caché de instrucciones. Algo similar en la caché de datos con la diferencia de que en la primera iteración ocurre un MISS de lectura pues el dato asociado a 1024(t0) no se encuentra en dicha caché. Por ende, se carga de memoria el bloque que contiene a esta dirección y, de esta manera, las 99 iteraciones siguientes resultan en HITS de lectura.
	subu	t1, t1, 1	-> Análogo al caso anterior.
	bnez	t1, loop	-> Análogo al caso anterior.

	# Destruimos el stack frame antes de retornar de main().
	#
	move	sp, fp		-> No se encuentra esta instrucción en la caché de instrucciones, por ende es un MISS. Se carga el bloque de 16 bytes que la contiene en la caché (el index es (n+3)%4). NO SÉ POR QUÉ HAY 99 HITS XD.
	lw	fp, 20(sp)	-> Se encuentra en el mismo bloque de caché que la instrucción anterior, razón por la cual es un HIT. Además, el dato asociado a la dirección 20(sp) fue cargado previamente en la caché (línea x), produciéndose un HIT de lectura. 
	addiu	sp, sp, 24	-> Se encuentra en el mismo bloque de caché que la instrucción anterior, razón por la cual es un HIT.

	# Para volver al sistema operativo cargamos un código de retorno nulo.
	#
	move	v0, zero	-> Análogo al anterior.
	jr	ra		-> No se encuentra esta instrucción en la caché de instrucciones, por ende es un MISS. Se carga el bloque de 16 bytes que la contiene en la caché (el index vuelve a ser n%4).
	.end	main

	.rdata
	.align	20
aligned:
	.skip	8192
